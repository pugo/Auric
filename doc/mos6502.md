# MOS 6502 implementation (src/chip/mos6502.cpp)

This document describes the MOS6502 emulation implemented in `src/chip/mos6502.cpp` and its public interface declared in `src/chip/mos6502.hpp`. It is intended as developer documentation for maintainers and integrators of the Oric emulator.

## High-level overview

- The `MOS6502` class emulates a NMOS 6502 CPU used by the Oric-1.
- It implements registers, processor flags, instruction timing, addressing modes and most official opcodes, plus a number of commonly used unofficial/illegal opcodes necessary for accurate emulation.
- The CPU is tightly coupled to the emulator `Machine`/`Memory` through function-pointer handlers for reading and writing memory. This avoids virtual function overhead and keeps per-cycle performance high.
- Interrupt handling (IRQ/NMI), BRK behaviour, stack semantics, decimal (BCD) mode, and known NMOS quirks are implemented.

Files of interest:
- `src/chip/mos6502.hpp` — public interface, types and handler typedefs.
- `src/chip/mos6502.cpp` — implementation, opcode dispatch, addressing macros, and helpers.
- `src/chip/mos6502_opcodes.hpp` — opcode value names used by the switch/cases.
- `src/chip/mos6502_cycles.hpp` — base cycle counts per opcode.


## Public API (important methods)

- Constructor: `MOS6502(Machine& machine)`
- Reset: `void Reset()` — resets registers, sets PC to the value at the reset vector, clears/sets flags as appropriate and initializes internal cycle state.
- Execution:
  - `uint8_t time_instruction()` — compute the number of cycles required by the instruction at the current `PC` (including page-cross penalties and branch penalties).
  - `bool exec(bool break_on_brk, bool& do_break)` — execute the CPU for one full instruction (internally the emulator tracks cycles; `exec` returns true when a full instruction has been executed). If `break_on_brk` is true, a BRK causes `do_break` to be set and the emulator can stop.
- Monitoring/debugging:
  - `Monitor& get_monitor()` — access the disassembler/debug monitor used by the CPU.
  - `void PrintStat()` / `void PrintStat(uint16_t address)` — prints a disassembly line and core register/flag status.
  - `void set_breakpoint(uint16_t address)` — add a breakpoint (the CPU will stop when it reaches the address).
- Snapshot support:
  - `void save_to_snapshot(Snapshot& snapshot) const` — store CPU state into the emulator snapshot structure.
  - `void load_from_snapshot(Snapshot& snapshot)` — restore CPU state from a snapshot.
- Flags/pack:
  - `uint8_t get_p() const` — return the packed processor status (P) register.
  - `void set_p(uint8_t p)` — set P from a byte.
- Interrupts: `void NMI()` and `void irq()` / `void irq_clear()` to trigger/clear IRQ/NMI lines.


## Public data (for fast chip-to-chip access)

The emulator exposes several registers and flags publicly (this is deliberate for performance):
- Registers: `uint8_t A, X, Y` — accumulator and index registers.
- Flags: `uint8_t N_INTERN, Z_INTERN; bool V, B, D, I, C;`
  - `N_INTERN` and `Z_INTERN` are internal representations used by the emulator: `N_INTERN` stores the full negative byte (bit 7), while `Z_INTERN` is inverted compared to the usual `Z` bit (the code defines `#define Z (!Z_INTERN)`). This is a local internal convention used by macros for efficient flag updates.
- Program counter / stack pointer: `uint16_t PC; uint8_t SP;`


## Memory handler typedefs and wiring

Handlers are plain function pointers that the `Machine` or other components must provide:

- typedef uint8_t (*f_memory_read_byte_handler)(Machine &oric, uint16_t address);
- typedef uint8_t (*f_memory_read_byte_zp_handler)(Machine &oric, uint8_t address);
- typedef uint16_t (*f_memory_read_word_handler)(Machine &oric, uint16_t address);
- typedef uint16_t (*f_memory_read_word_zp_handler)(Machine &oric, uint8_t address);
- typedef void (*f_memory_write_byte_handler)(Machine &oric, uint16_t address, uint8_t val);
- typedef void (*f_memory_write_byte_zp_handler)(Machine &oric, uint8_t address, uint8_t val);

Members available on the CPU instance (set by `Machine` during initialization):
- `memory_read_byte_handler`, `memory_read_byte_zp_handler`, `memory_read_word_handler`, `memory_read_word_buggy_handler`, `memory_read_word_zp_handler`, `memory_write_byte_handler`, `memory_write_byte_zp_handler`.

Example wiring (pseudo-code):

```cpp
// Example callback signature matching typedefs
uint8_t my_read_byte(Machine& m, uint16_t addr) {
    return m.memory.mem[addr];
}

// In Machine initialization
mos6502.memory_read_byte_handler = my_read_byte;
mos6502.memory_write_byte_handler = my_write_byte;
// etc...
```

The CPU implementation uses these handlers heavily via macros such as `READ_BYTE_IMM()` and `READ_ADDR_ABS()` to implement addressing and memory accesses.


## Instruction timing and cycle model

- The CPU separates cycle calculation (`time_instruction`) and execution (`exec`). The emulator typically calls `time_instruction` to count how many cycles the next instruction will need, and `exec` advances internal cycle counters and only performs the instruction when all cycles have elapsed.
- Page-cross penalties and conditional branch extra cycles are handled in `time_instruction()` by peeking bytes ahead and applying `PAGECHECK` logic (this matches 6502 timing: some instructions take an extra cycle if an index register causes a cross-page memory access).
- `exec` uses `instruction_load`, `instruction_cycles`, `current_cycle` to step cycles and only performs the opcode once the cycles are complete. It also handles deferred interrupt processing when an IRQ/NMI was raised during the previous instruction.


## Interrupts and BRK behaviour

- `NMI()` sets an internal `nmi_flag` which the CPU checks; `irq()` sets `irq_flag`.
- At instruction load time the CPU checks these flags and, when present and allowed (IRQ masked by I flag), pushes return address and status onto the stack and jumps to the vector.
- CPU sets `I = true` on interrupt entry, and emulates the NMOS quirk of clearing the decimal flag (`D = false`) when an interrupt happens.
- BRK pushes the return address and flags then vectors to the IRQ/BRK vector; `exec` supports an argument to break on BRK.


## Important behavior and quirks implemented

- JMP (indirect) page-wrapping bug: The MOS 6502 had a well-known bug when executing `JMP ($HHLL)` where the high byte is read from the start of the same page rather than the next page when the low byte is $FF. The implementation includes `read_word_buggy()` helper to emulate this behavior.

- Decimal mode (BCD) for `ADC`/`SBC`: The implementation includes BCD handling and adjusts flags accordingly.

- Interrupt/Decimal quirk: On interrupt entry (IRQ/NMI) the decimal flag `D` is cleared (matches NMOS behaviour noted in the source).

- `Z` flag internal inversion: The code stores `Z_INTERN` such that `Z` is defined as `(!Z_INTERN)` and `SET_FLAG_NZ(B)` assigns `N_INTERN = Z_INTERN = B`. This is an internal optimization used in many macroized places.

- Illegal opcodes: A number of unofficial opcodes (LAX, SLO, RLA, etc.) are implemented where needed to correctly run some Oric software.


## Stack usage

- Stack bottom base is defined as `STACK_BOTTOM = 0x0100`. Pushing/popping uses `SP` and stores into `memory.mem[STACK_BOTTOM | SP]`.
- On interrupt or BRK the return PC (address after the instruction) and status register are pushed following the 6502 conventions.


## Debugging & breakpoints

- `set_breakpoint(uint16_t address)` stores a breakpoint in a `std::set<uint16_t>`; if `has_breakpoints` is true `exec()` checks the PC and will set `do_break` to true when a breakpoint is hit.
- `Monitor` exposes `disassemble()` to print instruction mnemonics used by `PrintStat()`.


## Notable macros (for maintainers)

The implementation uses a set of macros to make the opcode implementations succinct. A few important ones:
- `READ_BYTE_IMM()` — read immediate byte at PC (advances PC).
- `READ_ADDR_ZP()`, `READ_ADDR_ABS()` — evaluate addresses for zero-page and absolute addressing modes.
- `READ_BYTE_ZP()`, `READ_BYTE_ABS(b)` — read bytes from calculated addresses using the memory handlers.
- `PUSH_BYTE_STACK(b)` / `POP_BYTE_STACK()` — push/pop single bytes using `SP` and `STACK_BOTTOM`.
- `PAGECHECK(n)` / `PAGECHECK2(a,b)` — helper macros used for page-cross extra-cycle checks.

These macros are defined at the top of `mos6502.cpp` and are central to the opcode switch logic.


## Examples

1) Basic execution loop (conceptual — the real emulator coordinates cycles across devices):

```cpp
bool do_break = false;
while (running) {
    // Optionally compute cycles beforehand
    uint8_t cycles = cpu.time_instruction();

    // The machine steps other devices a matching amount of cycles (not shown here)

    if (!cpu.exec(true, do_break)) {
        // instruction not finished yet (cycle accounting), continue stepping
    }

    if (do_break) break;
}
```

2) Wiring memory handlers in the `Machine` initialization (simplified):

```cpp
mos6502.memory_read_byte_handler = &Machine::read_byte_callback; // matching typedef
mos6502.memory_write_byte_handler = &Machine::write_byte_callback;
// zero page optimized callbacks as appropriate
```


## Testing and verification notes

- The code implements opcode timing and illegal opcodes to match real hardware behavior. When changing opcode implementations, run the test ROMs in `ROMS/` (e.g. 6502 tests present in the repo) and the project's test suite under `tests/` to ensure compatibility.
- Watch for the `Z_INTERN`/`N_INTERN` conventions when refactoring: macros depend on those semantics.


## Where to extend or change

- To add more illegal opcodes, follow the existing pattern in the opcode switch and add the entry to `mos6502_opcodes.hpp` and `mos6502_cycles.hpp` (cycle counts) as needed.
- If you need a different memory access strategy (for example to instrument reads/writes), swap the handlers on the CPU instance.


---

If you want, I can also:
- Add a concise class diagram showing public members and handler types.
- Produce a short unit-test / smoke test that runs a small 6502 instruction sequence using a minimal `Machine` stub and checks register results.

Which (if any) of those would you like next?
