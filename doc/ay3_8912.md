# AY-3-8912 (PSG) implementation

This document describes the AY-3-8912 (PSG) implementation in this repository (files: `src/chip/ay3_8912.hpp` and `src/chip/ay3_8912.cpp`) and correlates the implementation with the AY-3-8910/12 specification (see `doc/external/AY-3-8910.PDF` and `doc/external/AY-3-8910-GeneralInstrument.pdf`). It is intended for maintainers who need to understand the code, extend behavior, or write tests.

Summary / high-level
- The `AY3_8912` class models the classic 3-voice PSG used on many 8-bit machines. It implements tone generators, a noise generator, amplitude envelopes, register writes via the BC1/BC2/BDIR control pins, and a simple audio callback that mixes channels into samples.
- The implementation batches register writes (via `RegisterChanges`) so register updates can be scheduled relative to the audio cycle stream. The audio generation uses an internal cycle counter and converts cycles to samples using a fixed clock and a target sample rate.

Files
- `src/chip/ay3_8912.hpp` — public API, data structures, register enum and callbacks.
- `src/chip/ay3_8912.cpp` — implementation: register handling, audio engine, envelope and noise logic.

Public API (what other subsystems use)
- Constructor: `AY3_8912(Machine& machine)` — must be passed the owning `Machine`.
- `void reset()` — reset all internal PSG state.
- `void print_status()` — debug dump of channel/noise/envelope state.
- `void save_to_snapshot(Snapshot& snapshot)` / `void load_from_snapshot(Snapshot& snapshot)` — snapshot integration.
- `short exec()` — executed by the emulator main loop (currently only runs the register-change executor; returns 0).
- `void update_state()` — react to BC1/BDIR state and perform latch/read/write operations on the PSG registers. Intended to be called when the host toggles control pins.
- Pin setters: `set_bdir(bool)`, `set_bc1(bool)`, `set_bc2(bool)` — update internal BDIR/BC1/BC2 pin state.
- Static callbacks for wiring into Machine: `set_bdir_callback`, `set_bc1_callback`, `set_bc2_callback`, `update_state_callback`.
- `static void audio_callback(void* user_data, uint8_t* raw_buffer, int len)` — audio callback invoked by the frontend/audio subsystem. The frontend should call this to request PCM samples.
- Data bus handlers (must be set by the Machine): `f_read_data_handler m_read_data_handler` and `f_write_data_handler m_write_data_handler`.

Register map
- Registers (named in `Register` enum) and mapping to functionality:
  - 0/1: CH_A period low/high (12-bit tone period for channel A)
  - 2/3: CH_B period low/high
  - 4/5: CH_C period low/high
  - 6: Noise period (5-bit used)
  - 7: ENABLE (tones/noise/IO enables and IO dir)
  - 8/9/A: Amplitude channels A/B/C (bit4 selects envelope usage)
  - B/C: Envelope period low/high
  - D: Envelope shape/control (CONT / ATT / ALT / HOLD bits interpreted by code)
  - E: IO Port A data store (not fully modeled here)
  - F: IO Port B data store (if present)

Implementation notes & mapping to spec

Clocking and conversion to audio samples
- The code uses constants:
  - `cycles_per_second = 998400` (Oric CPU clock domain used for PSG timing)
  - `audio_frequency = 44100` (output sample rate)
  - `cycle_shift = 12` — internal fixed-point shift used to accumulate cycles per sample efficiently.
- `SoundState::cycles_per_sample` is computed as `(cycles_per_second << cycle_shift) / audio_frequency`. The `cycle_count` is advanced in the audio callback by `cycles_per_sample` each output sample.
- This approach schedules register-change proccessing and audio event generation against the same `cycle_count` domain and keeps audio deterministic relative to register writes.

Register writes and the BC1/BDIR protocol
- `update_state()` implements the typical AY write/read/latch behaviour:
  - When `BDIR=1` and `BC1=1` the code reads the address from the data bus and stores it in `current_register` (latch address).
  - When `BDIR=1` and `BC1=0` the code reads the data bus and writes the value into `state.registers[current_register]`.
  - If the written register affects audio (envelope, period, enable, amplitude), the write is recorded in `state.changes` via `write_register_change()` and later applied by `exec_register_changes()` in the audio callback or in periodic processing. The code locks the frontend audio before pushing register-change events (via `machine.frontend->lock_audio()` and `unlock_audio()`), ensuring thread safety with the audio thread.
- Note: the code path for reading from PSG (`BDIR=0, BC1=1`) is marked "not yet implemented". If reads are needed for IO/compatibility, they should be implemented using `m_write_data_handler` and the drive logic.

RegisterChange buffering and scheduling
- `RegisterChanges::buffer` is a `boost::circular_buffer<RegisterChange>` of capacity `register_changes_size` (32k). Writes add tuples of `(log_cycle, register, value)` and `exec_register_changes()` processes buffered changes whose cycle time has arrived.
- `write_register_change()` sets `changes.log_cycle` from `changes.new_log_cycle` if requested; this ensures writes are relative to the audio cycle domain used by the callback.

Tone generation
- Each `Channel` holds `tone_period`, `counter`, `value` (square wave state). In `exec_audio()` the channel counters are incremented each PSG cycle; when they reach `tone_period` the counter resets and `value ^= 1` toggles the tone phase.
- The implementation multiplies the 12-bit period composed from high/low registers by 8 when computing `tone_period`. It also ensures a minimum of 1 to avoid div-by-zero.

Noise generator
- `Noise` uses `period`, `counter`, `bit`, and a `rng` 32-bit shift register. The code toggles `noise.bit` when `noise.counter` reaches `noise.period`. When `noise.bit` is set it advances the LFSR using feedback of bit0 and bit3 to produce new bits (shifting into bit 17 and then shifting right). This is an LFSR-like sequence implementation matching the AY's pseudo-random noise behavior.

Envelope handling
- `Envelope` stores `period`, `counter`, `shape`, `shape_counter`, `out_level`, and flags `cont`, `hold`, `holding`.
- In `exec_audio()` the envelope `counter` increments and when it reaches `period` it advances `shape_counter`. `shape_counter` then indexes `ay38910_shapes[shape][shape_counter]` to map to the output level via the `voltab` table. The implementation sets `cont` and `hold` flags based on the `ENV_SHAPE` register and handles `holding` state when shape wraps or conditions are met.

Volume and output mixing
- `voltab[]` maps logical volume steps 0..15 to 16-bit output levels using a non-linear curve (copied from Oricutron). Envelope shapes map indices via `ay38910_shapes` to select levels.
- The per-PSG-sample mixing computes `out` as the sum of each channel's contribution: `((channel.value | channel.disabled) & ((noise.rng & 1) | channel.noise_diabled)) * channel.volume`. This expression combines tone, channel disabled flags and noise gating. The result is clipped to 32767 and assigned to `audio_out`.
- In `audio_callback`, each produced sample is duplicated for stereo (left and right) and written as `uint16_t` samples. The callback expects `raw_buffer` to be a buffer of 16-bit L/R pairs (the code treats raw buffer as `uint16_t*` and writes `audio_out` twice per sample).

Audio callback and threading
- `audio_callback` is the main audio output path used by the frontend. It:
  - Skips audio if `machine.warpmode_on` is set.
  - For each sample: computes the current cycle (`state.cycle_count >> cycle_shift`), applies pending register changes up to that cycle (`exec_register_changes()`), calls `exec_audio()` to advance tone/noise/envelope and compute `audio_out`, then writes the sample twice (stereo) and updates `cycle_count` by `cycles_per_sample`.
  - After producing the buffer it trims `changes` (`trim_register_changes()`), and updates `changes.new_log_cycle` and `changes.update_log_cycle` to keep the log cycle in sync.
- `update_state()` uses `machine.frontend->lock_audio()` and `unlock_audio()` where it writes changes to `changes.buffer` to avoid races with the audio thread.

Specials, omissions, and quirks
- Read-from-PSG (BDIR=0, BC1=1) is not implemented. If software or tests rely on reading PSG registers or IO port data reads, that path should be implemented and `m_write_data_handler` used to return the desired value onto the emulated data bus.
- The code duplicates samples as 16-bit stereo; ensure the frontend's expected PCM format matches (signed/unsigned, endianness). The buffer is treated as `uint16_t*` and sample values are 0..32767 (unsigned). If your audio backend expects signed 16-bit samples (-32768..32767) or floats, an adapter is needed.
- The `cycles_per_second` constant (998400) is used to convert PSG cycles to audio sampling rate. If you run at a different master clock, this value must be changed.
- `exec()` returns a `short` but currently only calls `state.changes.exec()`; other emulation frameworks may want exec to return number of cycles processed — consider clarifying or removing the return value.
- `state.trim_register_changes()` flushes changes into `exec_register_change()` when the buffer grows beyond a threshold (200). This helps keep the circular buffer manageable but could cause immediate application of many changes in a single thread; tests should cover timing.

Where to look in the code
- Mixing & audio generation: `SoundState::exec_audio()` (ay3_8912.cpp).
- Register scheduling: `RegisterChanges`, `SoundState::write_register_change()` and `exec_register_changes()`.
- BC1/BDIR handling and update logic: `AY3_8912::update_state()` and the static callbacks for wiring.
- Audio outp

References
- AY-3-8910 datasheet: `doc/external/AY-3-8910.PDF`
- General Instruments AY-3-8910 family programming notes: `doc/external/AY-3-8910-GeneralInstrument.pdf`
- Implementation files: `src/chip/ay3_8912.hpp`, `src/chip/ay3_8912.cpp`
