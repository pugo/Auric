# MOS 6522 (VIA) implementation in this repo

This document describes the MOS6522 (VIA) implementation in src/chip/mos6522.hpp / src/chip/mos6522.cpp and correlates the implementation with the official MOS 6522 specification (see doc/external/mos_6522.pdf).

Goals
- Explain the public API and wiring points in the emulator.
- Map how registers, timers and shift modes are implemented and how they relate to the spec.
- Point out implementation-specific behaviour, omissions and quirks to be aware of when extending or testing the VIA.

Files
- src/chip/mos6522.hpp — public API, types, typedefs and the `State` struct.
- src/chip/mos6522.cpp — implementation: timers, shift register, I/O handling, interrupts, and callback invocation.
- doc/external/mos_6522.pdf — reference specification used to correlate behaviour.

Overview
---------
The `MOS6522` class emulates the MOS Technology 6522 Versatile Interface Adapter used by the Oric hardware. The chip provides:
- Two 8-bit I/O ports (A and B) with data-direction registers.
- Two timers (T1 and T2) with one-shot and free-running behaviours.
- A serial shift register (SR) and related modes controlled by the ACR register.
- Peripheral control (CA1/CA2/CB1/CB2) controlling edge sensitivity, handshaking and pulses.
- Interrupt flags and enables (IFR/IER) and IRQ signalling to the CPU.

Public API and integration points
----------------------------------
Key public members/methods (see `mos6522.hpp`):
- Constructor: `MOS6522(Machine& machine)`
- `void exec()` — step the VIA one clock cycle; performs timer updates, shift register activity, pulse handling and triggers callbacks.
- `uint8_t read_byte(uint16_t offset)` / `void write_byte(uint16_t offset, uint8_t value)` — read/write VIA registers using the 16-register map (ORB..IORA2).
- `void set_ira_bit(uint8_t bit, bool value)` / `void set_irb_bit(uint8_t bit, bool value)` — update input port bits; used by the rest of the emulator (keyboard, tape, etc.).
- `void write_ca1(bool)`, `void write_ca2(bool)`, `void write_cb1(bool)`, `void write_cb2(bool)` — update peripheral control lines (edge-detection and IRQ behaviour implemented in these).
- Snapshot helpers: `save_to_snapshot()` / `load_from_snapshot()`
- Callback function pointers (to be set by `Machine`):
  - `f_orb_changed_handler orb_changed_handler` — called when ORB is written.
  - `f_ca2_changed_handler ca2_changed_handler`, `f_cb2_changed_handler cb2_changed_handler` — called when CA2/CB2 change state.
  - `f_psg_changed_handler psg_changed_handler` — called when PSG interface signals change (used to update sound chip state).
  - `f_irq_handler irq_handler` / `f_irq_clear_handler irq_clear_handler` — used to assert/clear IRQ lines toward the CPU.

Register map
------------
The register offsets are exposed via the `Register` enum in the header. Important registers:
- ORB (0x00), ORA (0x01): output latches; reads combine outputs and inputs according to DDRx.
- DDRB (0x02), DDRA (0x03): data direction registers.
- T1C_L/H (0x04/0x05), T1L_L/H (0x06/0x07): T1 counter and latch behaviour.
- T2C_L/H (0x08/0x09): T2.
- SR (0x0A): shift register read/write.
- ACR (0x0B): aux control register (T1/T2 modes + SR modes and latch enables).
- PCR (0x0C): peripheral control register (edge selection and CA/CB behaviour).
- IFR (0x0D): interrupt flags (bit7 used as overall IRQ indicator in this implementation).
- IER (0x0E): interrupt enable register (writes with bit7 set set bits, with bit7 clear clear bits).
- IORA2 (0x0F): same as ORA but affects CA2 handshake specifically.

State layout (important fields)
--------------------------------
The `MOS6522::State` struct contains the emulated chip state:
- CA/CB control lines: `ca1, ca2, ca2_do_pulse`, `cb1, cb2, cb2_do_pulse`.
- I/O registers/latches: `ira`, `ira_latch`, `ora`, `ddra`, `irb`, `irb_latch`, `orb`, `ddrb`.
- Timers: `t1_latch_low/high`, `t1_counter`, `t1_run`, `t1_reload`; same for `t2_*`.
- Shift register: `sr`, `sr_counter` (counts bits, modulo 8), `sr_timer`, `sr_run`, `sr_first`, `sr_out_started`, `sr_out_gap_pending`.
- Control registers: `acr`, `pcr`, `ifr`, `ier`.

Behavior highlights (mapping to the spec)
-----------------------------------------
Timers
- T1 behaviour: the implementation supports one-shot and continuous modes determined by bits (handled in exec() by switching on `state.acr & 0xc0`).
  - When T1 is written to the high latch (T1C_H) the implementation copies latch into counter, sets `t1_reload` and `t1_run=true` which matches common usage.
  - The code implements the two major modes:
    - One-shot: under `case 0x00/0x80` the counter counts down and on underflow sets IRQ_T1 and clears `t1_run`.
    - Continuous: under `case 0x40/0xC0` it toggles `orb` bit 7 if ACR7 is set and sets `t1_reload` to 1 to rearm the counter.
  - Note: the implementation uses `t1_reload` as a small-delay reloading mechanism. This approach emulates reloading semantics observed on real NMOS parts.

- T2 behaviour: T2 is updated in `exec()` and can act as a one-shot or in pulse counting mode (depending on `acr & 0x20`). `set_irb_bit()` contains special handling when `ac`r bit 5 (PB pulse control) is set: it decrements T2 when PB6 transitions from high to low (this maps to the Oric wiring where PB6 is used for tape motor/pulse counting).

Shift Register (SR)
- The SR supports multiple modes via bits in the ACR (see header comments). The implementation covers the key modes:
  - Shift in under T2 control
  - Shift in under O2 (output 2) control
  - Shift out free-running at T2 rate
  - Shift out under T2 control
  - Shift out under O2 control
  - External clock modes are acknowledged in code comments but marked not implemented.
- Important code notes:
  - `sr_run` is set by read/write accesses to SR.
  - For T2-driven shift modes, a `sr_timer` is used as a countdown derived from `t2_latch_low` (the low byte), with an extra cycle handling (see `sr_first` and `sr_out_gap_pending`) that matches quirks of NMOS hardware and real-device observations.
  - On shift-out completion the code sets `IRQ_SR` and uses `sr_out_gap_pending` to insert an extra period after each byte. The comment notes this behaviour is empirical (not described in the datasheet) but required for compatibility with Oric software.

Peripheral Control (CA1/CA2/CB1/CB2)
- CA1/CB1: edge-detection input lines. The `pcr` selects which edge triggers the CA1/CB1 interrupt. `write_ca1()` and `write_cb1()` implement edge detection; when an active edge is detected the code calls `irq_set(IRQ_CA1)` / `irq_set(IRQ_CB1)` and sets latches if configured.
- CA2/CB2: configurable handshake/outputs. The implementation recognizes control modes and implements:
  - Direct set/clear
  - Pulse-on-read/write (`*_do_pulse` is toggled and cleared in `exec()` next cycle to produce a 1-cycle low pulse)
  - Manual level control
- The code calls `ca2_changed_handler` or `cb2_changed_handler` callbacks when CA2/CB2 change state so the rest of the emulator (printer/PSG/tape) can react.
- A small implementation detail: `read_byte()` and `write_byte()` clear or set CA2/CB2 behaviour depending on `pcr` mode values — see the switch statements for ORA/ORB handling.

Interrupts and IFR/IER
----------------------
- The `ifr` holds individual IRQ bits; `ier` holds enables. `irq_set()` sets bits in `ifr` and calls `irq_handler(machine)` when an interrupt fires. `irq_clear()` clears bits and calls `irq_clear_handler(machine)` when there are no more enabled IRQs.
- `read_byte(IFR)` returns the IFR; `read_byte(IER)` returns IER | 0x80 (the header documents this behavior; the real chip hides bit7 when read as IER — this code follows the common emulation approach of returning IER | 0x80).
- Writing IER: writing with bit7=1 sets the bits in IER; with bit7=0 clears the bits — this matches the specification and the implementation handles it exactly.

I/O read/write semantics and latches
------------------------------------
- Reads to ORA/ORB combine the output latch and input pins according to the DDRx (output bits return `ora & ddra`, input bits return `ira & ~ddra`). The implementation also supports input latching controlled by ACR (PA/PB latch enable bits); when the corresponding IRQ_CA1/IRQ_CB1 is set and latch enable is on, the latched value is returned.
- Writes to ORA/ORB update `ora`/`orb`, perform CA/CB handshake/pulse behaviour based on PCR, and trigger callbacks (`ca2_changed_handler`, `cb2_changed_handler`, `psg_changed_handler`, `orb_changed_handler`).

Implementation-specific details & quirks
--------------------------------------
These are not necessarily departures from the real chip, but are important to know when modifying or testing the code:

- Pulse handling: CA2/CB2 pulse-on-read/write is implemented via `*_do_pulse` flags which are turned off in the first step of `exec()`. This produces a single-cycle low pulse; the comment in `exec()` documents this.

- SR external clock modes: The code contains handling for external-clock SR modes but marks external-clock modes as "not implemented" in comments. If you rely on external clock behaviour, this area needs extension.

- `sr_out_gap_pending`: an extra gap cycle after every shifted-out byte is inserted. The code comments that this is "Not documented, but analysis of the real hardware shows a full count cycle gap after each byte." This is an empirical compatibility tweak important for some Oric loaders.

- `write_ca1()` prints a debug `fprintf` line (with a number of internal state values). This is a heavy-weight log that may be noisy; consider replacing or gating it behind a debug flag.

- `set_irb_bit()` contains pulse-counting logic when `state.acr & 0x20` (PB pulse mode) is enabled. It decrements `t2_counter` on a specific edge of PB6, which is used to implement tape/pulse counting behaviour in the Oric wiring.

- Some PCR modes cause the code to clear IRQ flags on reads/writes of ORA/ORB (see `irq_clear(IRQ_CA2)`/`irq_clear(IRQ_CB2)` in read_byte/write_byte). This is consistent with the handshake semantics documented in the datasheet but keep the behaviour in mind when testing.

Unimplemented / partially implemented items
-------------------------------------------
- External clocking modes for SR are acknowledged but marked as not implemented.
- Some peripheral control combinations or exotic PCR/ACR encodings may not be fully exercised by the existing emulator tests; add targeted tests if you implement or change those behaviours.

Testing and validation
-----------------------
- The repo contains unit tests and test ROMs. When editing VIA behaviour, run unit tests and run Oric ROMs that exercise keyboard, tape and PSG interactions.
- Helper functions in the header are available to facilitate unit testing:
  - `get_t1_counter()` and `get_t2_counter()` return internal counter values without affecting IRQ flags.
  - `set_ifr(uint8_t)` lets tests inject IFR states directly.
- Recommended tests:
  - Verify T1 one-shot and continuous modes, including orb bit 7 square wave emission when ACR7 is set.
  - Verify SR modes that shift in/out at T2 rate and check that IRQ_SR is set after a full byte.
  - Verify CA/CB handshake/pulse modes and that callbacks receive CA2/CB2 changes.
  - Verify IER/IFR behaviour: setting/clearing bits and that irq_handler/irq_clear_handler are invoked as expected.

Examples (wiring to Machine)
----------------------------
The `Machine` initialisation should set callbacks to connect VIA changes to other devices. Example (pseudo-C++):

```cpp
// In Machine setup
via.orb_changed_handler = [](Machine &m, uint8_t orb){ m.update_printer_or_psg(orb); };
via.ca2_changed_handler = [](Machine &m, bool val){ m.on_ca2_change(val); };
via.cb2_changed_handler = [](Machine &m, bool val){ m.on_cb2_change(val); };
via.psg_changed_handler = [](Machine &m){ m.update_psg(); };
via.irq_handler = [](Machine &m){ m.mos6502.irq(); };
via.irq_clear_handler = [](Machine &m){ m.mos6502.irq_clear(); };
```

(Adapt to your code base's function pointer binding style — the project already wires these in `src/machine.cpp`.)

Where to look when changing behaviour
-------------------------------------
- `mos6522.cpp` — main logic for timers and SR modes.
- `read_byte()` / `write_byte()` implementations — important for handshake behaviour and side effects (IRQ clearing, pulses and callbacks).
- `set_irb_bit()` and `write_cb1()` / `write_ca1()` — input edge handling and latch logic.

References
----------
- MOS Technology 6522 VIA specification: `doc/external/mos_6522.pdf`
- Implementation: `src/chip/mos6522.hpp` and `src/chip/mos6522.cpp`
